;
; X1 compatible IPL
;
; programed by NAKAUE,T
;
; These codes are licensed under CC0.
; http://creativecommons.org/publicdomain/zero/1.0/deed.ja
;
; 2020-07-31 ver0.1.0 first version
;                     武田君のエミュレータでS-OS SWORDを起動できた
;                     バイナリサイズ 950byte，未実装機能があるのに大きい
; 2020-08-01 ver0.2.0 リファクタリング
;                     ディスク関係以外のアドレスをオリジナルと合わせた
;                     連続空きメモリ134バイト
; 2020-08-03 ver0.3.0 ディスク関係並べ替え
;                     IPL ROMからRAMへの切り替えをRAM上で行うようにした
;                     起動時にWIDTH40にする処理で，8255への出力を追加
;                     連続空きメモリ118バイト
; 2020-08-04 ver0.3.1 ディスク関係リファクタリングとデバッグ
;                     ファイルバッファの位置を直し忘れていた
;                     ファイルバッファが60K CP/Mに潰されるので対策
; 2020-08-05 ver0.3.2 パレット初期化を追加
; 2020-09-13 ver0.4.0 BASIC ROMボードCZ-8RBに対応(実機未所有のため，仕様解説のみで確認)
;                     EMM0からの起動に対応(CZ-8RBと微妙に仕様が違って面倒)
;                     1081バイト。ついに1KB突破……
;                     そもそもオリジナルのROMサイズを1KBだと勘違いしていた
;                     (正しくは4KB)
; 2020-09-15 コメントのみ修正
; 2021-03-03 ver0.4.1 ディスクREAD(021ah)にキャリーフラグのクリアを追加
;                     X-DOS起動不具合対策
; 2022-02-11 ver0.5.0 CMTブート追加のためのリファクタリング
;                     メニューの大文字/小文字を無視するようにした
; 2022-02-11 ver0.6.0 CMTブート対応
; 2022-02-11 ver0.6.1 CMTブート時のリーダ部(1の連続)の読み飛ばし方法を変更
;                     ファイル名拡張子(.Sys)のチェックをやめた
;                     RuinousXIII起動不具合対策
; 2022-02-20 ver0.7.0 ROMブートの不具合修正
;                     ブートセクタの開始アドレスをオフセット1dhからの3バイトに修正
;                     (元は1ehからの2バイト)
;                     EMMとROMのルーチン共用をやめ内部構造が大きく変わったため，バージョン番号を上げた
;                     デバッグ支援用にモニタの実装を開始
; 2022-02-20 ver0.7.1 リファクタリング
; 2022-02-23 ver0.7.2 8255の設定を追加
;                     X1 Fのデモディスクがおかしいのはこれが原因だった
;                     エラーステータス表示を消した(入らないのであきらめた)
;                     アドレス固定エントリのorgを減らし，代わりにORG_XXXXラベルを置いた
;                     ビルド時に.lstファイルのORG_XXXXラベルをチェックすること
;
; かつて X1エミュの部屋(http://www.turboz.to/)に掲載されていた
; ぷにゅ氏作の IPL ver1.01(x1ipl101.zip,IPLROM.z80)を参考にしている
;
; その他の参考文献
; [1] X1 turbo  BIOSの解析, 稲葉 康治, Oh!MZ 1985年1月号, p.97～109
; [2] IOCS DATA LIST, 泉 大介ら, Oh!MZ 1986年11月号, p.76～
; [3] 試験に出るX1, 祝 一平, 日本ソフトバンク, 1987
; [4] HuBASIC Format詳細, BouKiCHi, https://boukichi.github.io/HuDisk/HuBASIC_Format.html
;   2020-07-31 閲覧
; [5] 試験に出ないX1 第０章 まだまだ完全無欠にならないI/Oマップ, X1cetner, http://www.x1center.org/sdx1/sdx1_0.html
;
; 開発にあたり武田氏のX1エミュレータ eX1 (http://takeda-toshiya.my.coocan.jp/)を
; 全面的に使用した。eX1の強力なデバッグ機能のお陰でこのプラグラムを作りえた。


; FDD0-3およびROM，EMM，RAM，CMTからの起動を実装した
; Timer関係を実装しない
; モニタの実装が未着手

; 以下のエントリを固定番地とする
; 0066h : NMIリセット(ok)
; 00f5h : IPLエラー処理?(未実装)
; (01cfh : IPL overlay? x1ipl101で固定アドレスとしているが，不要？)
; 021ah : IPL用ディスクREAD
; 038ah : IPL用KEY入力(ok)
; 03cbh : IPL用メッセージ表示(ok)
; 03d9h : IPL用1文字表示ルーチン(ok)
;
; 以下のバッファを固定番地とする
; 0ff80h : カーソルxy
; 0ff86h : テキスト色
; 0ff87h : ドライブ番号

; ワークエリアアドレス

WRKTOP          equ     0ff80h          ; ワークエリアの先頭アドレス
TXTCUR          equ     WRKTOP + 0h     ; カーソルxy
;                       WRKTOP + 2h     ; 初期化後の0を維持すること
;                       WRKTOP + 3h     ; 初期化後の0を維持すること
;                       WRKTOP + 4h     ; 初期化後の0を維持すること
TXTATR          equ     WRKTOP + 6h     ; テキスト色
IPLDRV          equ     WRKTOP + 7h     ; ドライブ番号
                                        ;(ただしROM起動の場合22h，EMM起動の場合15h)
WRKSIZ          equ     20h             ; ワークエリアの長さ

REDIREC         equ     WRKTOP + 10h    ; IPL ROMからRAMに切り替えるリダイレクタ
EXECADR         equ     REDIREC + 3     ; 実行アドレス
INPBUF          equ     WRKTOP + 10h    ; モニタの入力文字列用バッファ(リダイレクタ領域と共用)
INPSIZ          equ     0eh             ; モニタの入力文字列用バッファの長さ
MONADR          equ     WRKTOP + 1eh    ; モニタのアクセス中アドレス

FILEBUF         equ     0fe00h          ; ファイル読込みバッファ
                                        ; +00h ブートフラグ(1バイト)
                                        ; +01h ファイル名(13バイト)
                                        ;      拡張子と連続で扱う。間のごみが表示されてもご愛敬
                                        ; +0eh 拡張子(3バイト)
                                        ;      参考文献[4]によれば'Sys'でなければならないが，チェックをやめた
                                        ; +11h パスワード(1バイト)
                                        ;      無視。0を書き込んで文字列終端にしている
                                        ; +12h サイズ(2バイト)
                                        ; +14h 読込みアドレス(2バイト)
                                        ; +16h 実行アドレス(2バイト)
                                        ; +18h 日付(6バイト)
                                        ; +1dh ディスク上のオフセット(3バイト)
                                        ;      参考文献[4]によれば+1dhが未使用，+1ehが開始セクタとなっているが，
                                        ;      +1dhからの3バイトでオフセットバイト数を示し，
                                        ;      1セクタ256バイトのFDDやEMMでは常に+1dhに00が入っていると考えるとCZ-8RBとの整合が取れる


; 以下はturbo BIOSで使用
COLORF          equ     0f8d0h
CLSCHR          equ     0f8d1h

; IOアドレス
IOEMM_L         equ     0d00h           ; EMM アドレス下位
IOEMM_M         equ     0d01h           ; EMM アドレス中位
IOEMM_H         equ     0d02h           ; EMM アドレス上位
IOEMM           equ     0d03h           ; EMM データ読み書き
IOROM_H         equ     0e00h           ; BASIC ROMボード アドレス上位
IOROM_M         equ     0e01h           ; BASIC ROMボード アドレス中位
IOROM_L         equ     0e02h           ; BASIC ROMボード アドレス下位
IOROM           equ     0e03h           ; BASIC ROMボード データ読出し
IOFDCCR         equ     0ff8h           ; FDC コマンドレジスタ
IOFDCTR         equ     0ff9h           ; FDC トラックレジスタ
IOFDCSR         equ     0ffah           ; FDC セクタレジスタ
IOFDCDR         equ     0ffbh           ; FDC データレジスタ
IOFDCNO         equ     0ffch           ; ドライブNo./サイド/モーターON
IOPALET         equ     1200h           ; パレット
IOCRTC          equ     1800h           ; CRTC レジスタ
IO80C49         equ     1900h           ; サブCPU
IO8255B         equ     1a01h           ; 8255 port B (CMT読出し)
IO8255C         equ     1a02h           ; 8255 port C
IO8255L         equ     1a03h           ; 8255 CWR(controL)
IOIPLOF         equ     1e00h           ; IPL ROM OFF
IOATTR          equ     2000h           ; アトリビュートVRAM
IOTEXT          equ     3000h           ; テキストVRAM
TXTSIZ          equ     800h            ; テキストVRAMのサイズ

; IOATTRとIOTEXTで異なるビット位置
; log2((IOATTR ^ IOTEXT) >> 8)
BIT_ATTR_TEXT   equ     4

; テキストクリアの標準色
TEXT_STD        equ     2007h           ; 20=SPC,07=白


        org     00000h

; ----------------------------------------------------------
; メインルーチンとメニュー
; ----------------------------------------------------------

; IPL起動
IPLBOT:

        ; ワークエリアの初期化 (インライン展開済み)
        ; 11バイト
INIT_WORK:
        ld      sp, WRKTOP + WRKSIZ     ; 初期化用の仮設定
        ld      hl, 0
        ld      b, WRKSIZ / 2
INIT_WORK_1:
        push    hl
        djnz    INIT_WORK_1
        ; 0以外としたいワーク(たとえばTXTATR)が初期化されていないので注意
INIT_WORK_END:

        ld      sp, 0                   ; ずれたので再設定
        ld      hl, PARM40              ; CRTCをWIDTH40で初期化

        ; 8255を初期化 (インライン展開済み)
        ; 7バイト
INIT_8255:
        ld      bc, IO8255L
        ld      a, 82h                  ; ポートBのみ入力
        out     (c), a
INIT_8255_END:

        ; CRTCを初期化 (インライン展開済み)
        ; パラメータ
        ;   hl : 初期化パラメータの先頭アドレス
        ; レジスタ破壊 af bc hl
        ; 22バイト
INIT_CRTC:
        ld      a, 13                   ; CRTCレジスタ番号
INIT_CRTC_1:
        ld      bc, IOCRTC
        out     (c), a
        inc     c
        inc     b
        outi                            ; outiの仕様に注意
        dec     a
        jp      p, INIT_CRTC_1

        ld      bc, IO8255C + 100h
        outi
INIT_CRTC_END:

        call    CLR_PALET

        ; メインループ
        ; 38バイト
IPL_LOOP:
        call    CLR_VRAM_ALL

        ld      a, 2                    ; 赤
        ld      (TXTATR), a
        ld      de, MSG_WELCOME
        call    IPLPRN_XY
        ld      a, 7                    ; 白
        ld      (TXTATR), a

        ld      de, MSG_WAITING
        call    IPLPRN_XY
        call    PRT_DRV

        call    IS_DRV_RDY              ; IPLDRV(初回はFDD 0)の挿入チェック
        jr      nc, IPL_LOAD            ; 挿入されていれば起動

IPL_LOOP2:
        call    IPL_MENU                ; メニュー表示と入力待ち
        jr      IPL_LOOP
IPL_LOOP_END:

        ; 読込みエラー等 (インライン展開済み)
        ; 5バイト
ERR_LOAD:
        ld      de, MSG_ERROR
        jr      ERR_MISSING_1
ERR_LOAD_END:

        ; NMIリセットがアドレス066hとなるよう，調整する
        ; ここに3バイトあき
        nop
        db      0, 0

        ; 読み込むべきファイルが見つからないエラー (インライン展開済み)
        ; 9バイト
ERR_MISSING:
        ld      de, MSG_MISSING
ERR_MISSING_1:
        call    IPLPRN_XY
        call    WAIT_MOMENT
        ; ループの戻りをNMIリセットと共用

        ; NMIリセットのエントリ(メニューに戻す)
ORG_0066:
        ; org     0066h
RST_066H:
        jr      IPL_LOOP2


        ; ここに8バイトあき
        nop
        db      0, 0, 0, 0, 0, 0, 0


; パレットの初期化
; TXTCUR+2から3バイトが0である前提
; レジスタ破壊 f b hl
; 12バイト
CLR_PALET:
        ld      hl, TXTCUR + 2
        ld      b, HIGH(IOPALET + 100h)
        outi
        outi
        outi
        ret
CLR_PALET_END:


; ドライブ番号の表示
; パラメータ
;   (0ff80h) TXTCUR カーソルxy
;   (0ff86h) TXTATR アトリビュート
;   (0ff87h) IPLDRV ドライブ指定(0～3)
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 a
; FDD以外では表示がおかしくなる(しかしEMMとROMは一瞬なので気にしない)
; 8バイト
PRT_DRV:
        ld      a, (IPLDRV)
        add     a, 30h
        jp      IPLPTC                  ; 飛び先でリターン
PRT_DRV_END:


; 数秒待つ
; レジスタ破壊 af bc de
; 13バイト
WAIT_MOMENT:
        ld      b, 10
        ld      de, 0
WAIT_MOMENT_1:
        dec     de
        ld      a, d
        or      e
        jr      nz, WAIT_MOMENT_1
        djnz    WAIT_MOMENT_1
        ret
WAIT_MOMENT_END:


; ファイルの読込みと実行
; 88バイト
IPL_LOAD:
;        call    CLR_VRAM_TOP           ; 長いメッセージで上書きされるので省略
        ld      de, MSG_LOOKING
        call    IPLPRN_XY
        call    PRT_DRV
        ld      a, (IPLDRV)
        cp      12h                     ; CMTの場合メッセージが異なる
        jr      nz, IPL_LOAD_0
        ld      de, MSG_LOOKCMT
        call    IPLPRN_XY

IPL_LOAD_0:
        call    LOAD1ST_COM             ; 先頭セクタの読込み
        jr      nz, ERR_LOAD            ; デバイスがおかしい？
        call    CHECK1ST                ; 起動フラグの確認
        jr      nz, ERR_MISSING         ; フラグ等がおかしい

        ; リダイレクタをRAMに書き込む
        ld      de, (FILEBUF+16h)       ; 実行アドレス
        call    WRITE_REDIRECTOR

        ; ファイル名の表示
        call    CLR_VRAM_TOP
        ld      de, MSG_LOADING
        call    IPLPRN_XY
        ld      de, FILEBUF+1
        call    IPLPRN

        ld      a, (IPLDRV)
        cp      12h                     ; CMTの場合別処理
        jp      z, IPL_CMT

        ; ファイル本体の読込み
        ld      bc, (FILEBUF+12h)       ; プログラムサイズ(byte)
        ld      hl, (FILEBUF+14h)       ; ロードアドレス
        ld      a,  (FILEBUF+1dh)       ; 開始アドレス下位バイト
        ld      de, (FILEBUF+1eh)       ; 開始アドレス中・上位バイト(ほぼそのままセクタ)
        call    LOADFILE_COM
        jp      nz, ERR_LOAD            ; デバイスがおかしい？

IPL_LOAD_1:
        ld      bc, IOIPLOF
        jp      REDIREC                 ; IPL終了
IPL_LOAD_END:


; メニュー表示と選択
; 戻り値
;   (0ff87h) IPLDRV ドライブ指定(0～3，10h=EMM，11h=ROM，12h=CMT)
; レジスタ破壊 af af' bc de hl
; 39バイト=表示20バイト+入力19バイト
IPL_MENU:
        call    CLR_VRAM_TOP
        ld      hl, MSG_ADDR_MENU
        ld      a, (hl)                 ; メッセージの行数
        inc     hl
IPL_MENU_1:
        ld      e, (hl)
        inc     hl
        ld      d, (hl)
        inc     hl
        ex      af, af'
        call    IPLPRN_XY
        ex      af, af'
        dec     a
        jr      nz, IPL_MENU_1

INP_MENU:
        call    IPLKEY

        cp      '#'                     ; RAMから起動(謎機能)
        jp      z, EXEC_RAM

        call    SET_IPLDRV
        ret     nc                      ; 正常

        cp      'm'                     ; モニタ
        jp      z, EXEC_MON

        jr      INP_MENU                ; 無効文字
INP_MENU_END:


; ドライブ文字をIPLDRVに変換
; パラメータ
;   a : ドライブ文字
; 戻り値
;   (0ff87h) IPLDRV ドライブ指定(0～3，10h=EMM，11h=ROM，12h=CMT)
;   キャリ : 無効文字
;   a : 無効文字の場合に小文字化した元の文字
; レジスタ破壊 af bc
; 30バイト
SET_IPLDRV:
        cp      34h                     ; FDD(0-3)
        jr      c, SET_IPLDRV_2

        or      20h                     ; 全て小文字に統一

        ld      b, 40h                  ; IPLDRV = 10h
        cp      'e'                     ; EMMから起動
        jr      z, SET_IPLDRV_1

        inc     b                       ; IPLDRV = 11h
        cp      'r'                     ; BASIC ROM(CZ-8RB)
        jr      z, SET_IPLDRV_1

        inc     b                       ; IPLDRV = 12h
        cp      'c'                     ; CMTから起動

        scf
        ret     nz                      ; 無効文字
SET_IPLDRV_1:
        ld      a, b
SET_IPLDRV_2:
        sub     30h
        ret     c                       ; 無効文字
        ld      (IPLDRV), a
        ret
SET_IPLDRV_END:


; リダイレクタをRAMに書き込む
; ファイルを読み込む前に実行アドレスを書いておかないと
; CP/Mにバッファを潰される
; パラメータ
;   de : 実行アドレス
; レジスタ破壊 f hl
; 16バイト
WRITE_REDIRECTOR:
        ld      hl, REDIREC
        ld      (hl), 0edh              ; out (c), a
        inc     hl
        ld      (hl), 79h
        inc     hl
        ld      (hl), 0c3h              ; jp xxxx
        ld      (EXECADR), de
        ret
WRITE_REDIRECTOR_END:


; 先頭セクタのチェック
; パスワード領域を0にし，ファイル名の文字列を0終端にする
; 戻り値
;   ゼロ : エラーでnz
; レジスタ破壊 af hl
; 10バイト
CHECK1ST:
        ld      hl, FILEBUF + 11h       ; パスワード領域
        ld      (hl), 0                 ; パスワード領域をつぶし，文字列の終端0にする
                                        ; どうせパスワードをサポートしないので問題なし
        ld      l, LOW(FILEBUF)         ; 起動フラグ
        ld      a, (hl)
        dec     a
        ret
CHECK1ST_END:


; ----------------------------------------------------------
; 各ドライブ共通ルーチン
; ----------------------------------------------------------

; ドライブの準備確認(FDD・EMM・ROM・CMT共通)
; パラメータ
;   (0ff87h) IPLDRV ドライブ指定(0～3)
;            ただし12hの場合，CMTをチェック
;            その他4以上の場合無条件で準備完了(ノンキャリ)を返す
; 戻り値
;   キャリ : 準備未完で1
; レジスタ破壊 af bc de
; 38バイト
IS_DRV_RDY:
        ld      a, (IPLDRV)
        cp      12h
        jp      z, IS_CMT_READY         ; CMTの場合
        cp      4
        jr      nc, IS_DRV_RDY_2        ; EMM・ROMの場合(無条件でOK)

        ; ここからFDDの準備
        or      80h
        ld      bc, IOFDCNO
        out     (c), a
        ld      c, LOW(IOFDCCR)

        ld      de, 0
IS_DRV_RDY_1:
        in      a, (c)
        jp      p, IS_DRV_RDY_2
        dec     de
        ld      a, d
        or      e
        jr      nz, IS_DRV_RDY_1
        scf
        ret
IS_DRV_RDY_2:
        and     a
        ret
IS_DRV_RDY_END:


; 先頭セクタの読込み(FDD・EMM・ROM・CMT共通)
; パラメータ
;   (0ff87h) IPLDRV ドライブに応じて処理を振り分け
; 戻り値
;   ゼロ : エラーでnz
; レジスタ破壊 af bc de hl
; 15バイト
LOAD1ST_COM:
        ld      a, (IPLDRV)
        cp      4
        jp      c, LOAD1ST              ; FDDの場合
        cp      12h
        jp      z, CMT_LOAD1ST          ; CMTの場合
        jr      EMM_LOAD1ST             ; EMM・ROM共通
LOAD1ST_END:


; ファイルの読込み(FDD・EMM・ROM共通)
; IPLDRVの内容に応じて飛び先を変える
; パラメータ
;   (0ff87h) IPLDRV ドライブに応じて処理を振り分け
;   bc : 読込みバイト数
;   de+a : 開始オフセット
;   (FDDとEMMの場合 de : レコード番号(トラック+サイド+セクタ))
;   hl : 読込みバッファのアドレス
; レジスタ破壊 af bc de hl af'
; 25バイト
LOADFILE_COM:
        ld      ixh, a                  ; 未定義命令
        ld      a, (IPLDRV)
        cp      11h                     ; ROM
        jr      c, LOADFILE_COM_1       ; FDDかEMM

        ld      a, ixh                  ; 未定義命令
        jp      ROM_LOADFILE            ; ROM

LOADFILE_COM_1:
        ; FDDとEMMの場合
        dec     bc                      ; バイト数からセクタ数を計算(256で割っている)
        inc     b
        cp      10h
        ld      a, b

        jp      z, EMM_LOADFILE         ; EMM
        jp      LOADFILE
LOADFILE_COM_END:

; ----------------------------------------------------------
; EMM・BASIC ROM関連ルーチン
; ----------------------------------------------------------

; EMMまたはROMのIOアドレスをセットする
; パラメータ
;   ゼロ : ROMの時にセット
; 戻り値
;   bc : IOアドレス(IOEMM_L，IOROM_H)
; レジスタ破壊 af
; 7バイト
EMM_SETIO:
        ld      bc, IOEMM_L
        ret     nz                      ; 条件リターンは好きではないが
        ld      b, HIGH(IOROM_H)
        ret
END_EMM_SETIO:


; EMMまたはROMから先頭32バイトを読みだす
; パラメータ
;   ゼロ : ROMの場合セット
; 45バイト
EMM_LOAD1ST:
        cp      11h                     ; ROMの場合
        call    EMM_SETIO
        ld      ix, EMM_LOAD1ST_2       ; EMMの場合の分岐アドレス
        jr      nz, EMM_LOAD1ST_1
        ld      ix, EMM_LOAD1ST_3       ; ROMの場合の分岐アドレス
EMM_LOAD1ST_1:
        xor     a

        out     (c), a                  ; 読出しアドレスに0をセット
        inc     c                       ; ROMは上位・中位・下位，EMMは下位・中位・上位
        out     (c), a
        inc     c
        out     (c), a
        inc     c

        ; bcは読出しアドレスになっている
        ld      hl, FILEBUF
EMM_LOAD1ST_2:
        ini                             ; in tmp,(c) ; ld (hl),tmp ; dec b ; inc hl
        inc     b
        inc     a
        cp      0x20
        jr      z, EMM_LOAD1ST_4

        jp      (ix)                    ; EMMとROMで分岐
EMM_LOAD1ST_3:                          ; ROMの場合のみ
        dec     c                       ; 読出しポートの前が下位アドレス
        out     (c), a
        inc     c
        jr      EMM_LOAD1ST_2

EMM_LOAD1ST_4:

        ret
EMM_LOAD1ST_END:


; EMMファイルの読込み
; パラメータ
;   a : セクタ数
;   de : レコード番号(トラック+サイド+セクタ)
;   hl : 読込みバッファのアドレス
; レジスタ破壊 af bc de hl af' ix
; 26バイト
EMM_LOADFILE:
        ex      af, af'                 ; セクタ数を退避

        xor     a
        ld      bc, IOEMM_L
        out     (c), a                  ; アドレス 下位
        inc     c
        out     (c), e                  ; アドレス 中位
        inc     c
        out     (c), d                  ; アドレス 上位
        inc     c                       ; bcは読出しアドレス

        ex      af, af'                 ; セクタ数を復帰
        ld      d, a

EMM_LOADFILE_1:                         ; 1セクタ256バイト読込み
        ini                             ; in tmp,(c) ; ld (hl),tmp ; dec b ; inc hl
        inc     b
        inc     a
        jr      nz, EMM_LOADFILE_1

        dec     d                       ; 残りセクタ数の確認
        jr      nz, EMM_LOADFILE_1

        ret
EMM_LOADFILE_END:


; ROMファイルの読込み
; パラメータ
;   bc : 読込みバイト数
;   de+a : 開始オフセット
;   hl : 読込みバッファのアドレス
; レジスタ破壊 af bc de hl af' ix
; 48バイト
ROM_LOADFILE:
        ex      de, hl                  ; deがバッファアドレス，hlがアドレス上位中位
        push    bc                      ; バイト数を退避

        ld      bc, IOROM_H
        out     (c), h                  ; アドレス 上位
        inc     c
        out     (c), l                  ; アドレス 中位
        inc     c
        out     (c), a                  ; アドレス 下位

        ex      (sp), hl                ; アドレス上位中位を保存し，バイト数を戻す
        ex      de, hl                  ; deが読込みバイト数，hlがバッファアドレス
ROM_LOADFILE_1:
        inc     c                       ; bcは読出しIOアドレス
        ini                             ; in tmp,(c) ; ld (hl),tmp ; dec b ; inc hl
        inc     b

        dec     de                      ; 残りバイト数の確認
        ex      af, af'
        ld      a, d
        or      e
        jr      z, ROM_LOADFILE_2
        ex      af, af'

        ; ROMはオートインクリメントしてくれない
        dec     c                       ; 読出しポートの前が下位アドレス
        inc     a
        out     (c), a
        jr      nz, ROM_LOADFILE_1

        ; 下位アドレスがオーバーフロー
        ex      (sp), hl                ; バッファアドレスを保存し，アドレスを戻す

        inc     hl
        ld      bc, IOROM_H
        out     (c), h                  ; アドレス 上位
        inc     c
        out     (c), l                  ; アドレス 中位
        inc     c

        ex      (sp), hl                ; アドレスを保存し，バッファアドレスを戻す

        jr      ROM_LOADFILE_1

ROM_LOADFILE_2:
        pop     bc
        ret
ROM_LOADFILE_END:

; ----------------------------------------------------------
; FDD関連ルーチン
; ----------------------------------------------------------

; ちょっと待つ
; 呼び出し元のcall命令含め 146clock = 36.5usec
; レジスタ破壊 af
; 6バイト
; call 17clock
WAIT1:
        ld      a, 7                    ; 7clock
WAIT1_1:
        dec     a                       ; 4clock
        jr      nz, WAIT1_1             ; 12clock
        ret                             ; 10clock
WAIT1_END:


        ; ここにあきなし


; ファイルの読込み(アドレス固定)
; パラメータ
;   a : セクタ数
;   de : レコード番号(トラック+サイド+セクタ)
;   hl : 読込みバッファのアドレス
; レジスタ破壊 af bc de hl af'
; 76バイト
ORG_021A:
        ; org     021ah
LOADFILE:
        or      a                       ; キャリークリア
        ex      af, af'                 ; aレジスタ退避

        ld      a, e

        ; d←トラック番号+サイド
        ; d = HIGH(de << 4)
        rlca
        rl      d
        rlca
        rl      d
        rlca
        rl      d
        rlca
        rl      d

        ; e←セクタ番号(0オリジン)
        ld      a, e
        and     0fh
        ld      e, a

LOADFILE_1:
        ; ドライブ番号とサイドを指定してモータON
        ld      a, 1
        and     d                       ; f←サイド
        ld      a, (IPLDRV)
        jr      z, LOADFILE_2           ; サイド0だった
        or      10h                     ; サイド1だった
LOADFILE_2:
        or      80h                     ; モータON
        ld      bc, IOFDCNO
        out     (c), a

        ; トラックシーク
        ld      a, d
        srl     a
        call    FDC_SEEK                ; シーク
        ret     nz                      ; エラー

LOADFILE_3:
        ; 1セクタ読込み
        push    de
        ld      a,e
        call    FDC_READ
        pop     de
        ret     nz                      ; エラー

        ; セクタ数確認
        ex      af, af'
        dec     a
        jr      z, LOADFILE_4           ; 読込み完了
        ex      af, af'

        ; セクタ番号++
        ld      a, e
        inc     a
        and     0fh
        ld      e, a
        jr      nz, LOADFILE_3          ; 次も同じトラック

        ; トラック番号++
        ld      a, d
        inc     a
        ld      d, a
        jr      LOADFILE_1

LOADFILE_4:
        ld      a, (IPLDRV)             ; モータOFF
        ld      bc, IOFDCNO
        out     (c), a

        ret
LOADFILE_END:


; FDCリストア
; レジスタ破壊 af bc
; 2バイト
FDC_RESTORE:
        ld      a, 2
        ; 次のルーチン(FDC_CMD)へ続く


; FDCのコマンドレジスタに命令を与え，完了を待つ
; パラメータ
;   a : コマンド番号
; レジスタ破壊 af bc
; 5バイト
FDC_CMD:
        ld      bc, IOFDCCR
        out     (c), a
        ; 次のルーチン(WAIT_FDC_BUSY)へ続く


; FDCのBusy待ち
; bcレジスタがIOFDCCRでなければならない
; bレジスタが0fh(FDCのIOアドレスの上位)でなければならない
; レジスタ破壊 af bc
; 7バイト
WAIT_FDC_BUSY:
WAIT_FDC_BUSY_1:
        in      a, (c)
        and     81h
        jr      nz, WAIT_FDC_BUSY_1
        ret
WAIT_FDC_BUSY_END:


; FDCシーク
; パラメータ
;   a : トラック番号
; レジスタ破壊 af bc
;   ゼロ : エラーでnz
; 15バイト
FDC_SEEK:
        ld      bc, IOFDCDR
        out     (c), a
        ld      a, 1eh
        call    FDC_CMD
        in      a, (c)
        and     99h
        ret
FDC_SEEK_END:


; 先頭セクタの読込み
; 戻り値
;   ゼロ : エラーでnz
; レジスタ破壊 af bc de hl
; 7バイト
LOAD1ST:
        call    FDC_RESTORE
        ld      hl, FILEBUF
        xor     a
        ; 次のルーチン(FDC_READ)へ続く


; 1セクタ読込み
; トラック移動は完了しているものとする
; パラメータ
;   a : セクタ番号(0オリジン)
;   hl : 読込みバッファのアドレス
; レジスタ破壊 af bc de hl
; 43バイト
FDC_READ:
        ld      bc, IOFDCSR             ; セクタ番号のセット
        inc     a
        out     (c), a
        ld      c, LOW(IOFDCCR)
        call    WAIT_FDC_BUSY

        ld      d, LOW(IOFDCCR)         ; FDCステータスレジスタ
        ld      e, LOW(IOFDCDR)         ; FDCデータレジスタ
        ld      bc, IOFDCCR

        ld      a, 80h
        out     (c), a                  ; 読出し指示
        call    WAIT1
FDC_READ_1:
        in      a,(c)                   ; ステータス確認
        rrca                            ; BUSY?
        jr      nc,FDC_READ_2
        rrca                            ; DATA REQUEST?
        jr      nc,FDC_READ_1

        ld      c, e                    ; FDCデータレジスタ
        in      a, (c)
        ld      (hl), a
        inc     hl
        ld      c, d                    ; FDCステータスレジスタ
        jr      FDC_READ_1

FDC_READ_2:
        rlca    ; BACK STAT (RRCA <-> RLCA)
        ret
FDC_READ_END:


; ----------------------------------------------------------
; テキスト関係ルーチン (1)
; ----------------------------------------------------------

; テキストVRAMクリア(全画面) (アドレス変えてもよい)
; レジスタ破壊 af bc hl
; 10バイト
CLR_VRAM_ALL:
        ld      hl, 0
        ld      (TXTCUR), hl
        ld      a, HIGH(TXTSIZ)
        jr      CLR_VRAM_TOP_1          ; 飛び先でリターン
CLR_VRAM_ALL_END:


; テキストVRAMクリア(上部12行+αだけ) (アドレス変えてもよい)
; レジスタ破壊 af bc hl
; 5バイト
CLR_VRAM_TOP:
        ld      a, 2
CLR_VRAM_TOP_1:
        ld      hl, TEXT_STD
        ;jr      CLR_VRAM               ; 次のルーチンなので省略
        ; 次のルーチン(CLR_VRAM)へ続く


; テキストVRAMクリア(レジスタ指定) (アドレス変えてもよい)
; パラメータ
;   a : 埋めるバイト数 / 256
;   h : 埋めるキャラクタコード(通常 20h)
;   l : 埋めるアトリビュート(通常 7h)
; レジスタ破壊 af bc hl
; 22バイト
CLR_VRAM:
        ld      bc, IOTEXT
CLR_VRAM_1:                             ; テキストを256バイト分クリア
        out     (c), h
        inc     c
        jr      nz, CLR_VRAM_1
        res     BIT_ATTR_TEXT, b        ; アトリビュートアドレスに変換
                                        ; 例えば 30aah → 20aah
CLR_VRAM_2:                             ; アトリビュートを256バイト分クリア
        out     (c), l
        inc     c
        jr      nz, CLR_VRAM_2
        set     BIT_ATTR_TEXT, b        ; テキストアドレスに変換
        inc     b
        dec     a
        jr      nz, CLR_VRAM_1          ; 256*aバイト分のループ
        ret
CLR_VRAM_END:


; 改行
; パラメータ
;   (0ff80h) TXTCUR カーソルxy
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 f
;
; WIDTH40を仮定
; TXTCUR + (40 - X) = TXTCUR - (X - 40) を求めたい
;
; 39バイト
TXT_LTNL:
        push    hl

        call    TXT_ISLAST              ; HLに(TXTCUR)が入る
        jr      c, TXT_LTNL_3
        push    de
        push    hl

        ; X座標を得る(40で割った余り)
        ld      de, 40
        or      a
TXT_LTNL_1:
        sbc     hl, de
        jr      nc, TXT_LTNL_1

        ex      de, hl
        ; DE = X - 40 となっている

        ; TXTCUR - DE = TXTCUR - (X - 40)
        pop     hl
        or      a
        sbc     hl, de
        pop     de

TXT_LTNL_2:
        ld      (TXTCUR), hl
        pop     hl
        ret

TXT_LTNL_3:
        ; 最終行だった
        push    bc
        ld      h, a
        call    TXT_SCROLL              ; スクロールアップ
        ld      a, h
        pop     bc

        ld      hl, 40 * 24             ; 最終行
        jr      TXT_LTNL_2
TXT_LTNL_END:


; バックスペース
; パラメータ
;   (0ff80h) TXTCUR カーソルxy
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 af bc hl
; 19バイト
TXT_BS:
        ld      hl, (TXTCUR)
        dec     hl
        ld      (TXTCUR), hl
        push    hl

        call    MON_PRINTS
        call    MON_PRINTS
        pop     hl
        ld      (TXTCUR), hl

        ret
TXT_BS_END:


; カーソル表示
; パラメータ
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 af bc hl
; 13バイト
TXT_CURON:
        call    LD_TEXT_ADDR
        res     BIT_ATTR_TEXT, b        ; アトリビュートアドレスに変換
                                        ; 例えば 30aah → 20aah
        ld      a, (TXTATR)
        xor     10h
        out     (c), a

        ret
TXT_CURON_END:


; カーソル位置が最終行か？
; パラメータ
;   (0ff80h) TXTCUR カーソルxy
; 戻り値
;   hl : TXTCUR
;   キャリ : 
; レジスタ破壊 hl
; WIDTH40を仮定
; 20バイト
TXT_ISLAST:
        or      a
        push    af

        ld      hl, (TXTCUR)
        ld      a, h
        cp      HIGH(40 * 24)
        jr      nz, TXT_ISLAST_1
        ld      a, l
        cp      LOW(40 * 24)
        jr      c, TXT_ISLAST_1

        ; 最終行だった
        pop     af
        scf
        ret
TXT_ISLAST_1:
        pop     af
        ret
TXT_ISLAST_END:


; 強制スクロールアップ
; レジスタ破壊 af bc
; WIDTH40を仮定
; 58バイト
TXT_SCROLL:
        push    ix
        ld      bc, IOTEXT              ; 転送先
        exx                             ; →裏
        push    bc
        ld      bc, IOATTR + 40         ; 転送元

TXT_SCROLL_1:
        in      a, (c)                  ; アトリビュート読出し
        ld      ixh, a                  ; 未定義命令
        set     BIT_ATTR_TEXT, b        ; テキストアドレスに変換
                                        ; 例えば 20aah → 30aah
        in      a, (c)                  ; テキスト読出し
        res     BIT_ATTR_TEXT, b        ; アトリビュートアドレスに変換
        inc     bc

        exx                             ; →表
        out     (c), a                  ; テキスト書込み
        res     BIT_ATTR_TEXT, b        ; アトリビュートアドレスに変換
        ld      a, ixh                  ; 未定義命令
        out     (c), a                  ; アトリビュート書込み
        set     BIT_ATTR_TEXT, b        ; テキストアドレスに変換
        inc     bc

        exx                             ; →裏
        ld      a, b                    ; 転送範囲チェック
        cp      HIGH(IOATTR + 40 * 25)
        jr      nz, TXT_SCROLL_1
        ld      a, c
        cp      LOW(IOATTR + 40 * 25)
        jr      nz, TXT_SCROLL_1

        ; 転送ループ終了
        pop     bc
        exx                             ; →表
        pop     ix
        ; BC = 最終行の頭(IOTEXT + 40 * 24)のはず

        ; 最終行+αをクリア(64バイト分)
        ld      a, HIGH(TEXT_STD)
        call    TXT_SCROLL_2            ; テキストで実行
        ld      a, LOW(TEXT_STD)
        ld      bc, IOATTR + 40 * 24    ; アトリビュートで実行
TXT_SCROLL_2:
        out     (c), a
        inc     c
        jr      nz, TXT_SCROLL_2
        ret
TXT_SCROLL_END:

; ----------------------------------------------------------
; キー入力関連ルーチン
; ----------------------------------------------------------

; IPL用KEY入力 (待たない)
; 戻り値
;   a : KEYコード
; レジスタ破壊 af bc
; 21バイト
KBHIT:
        ei                              ; サブCPUとの通信時に必要？
        call    WAIT_80C49_WR
        ld      bc, IO80C49
        ld      a, 0e6h                 ; e6=キー入力
        out     (c), a
        call    WAIT_80C49_WR
        di

        call    READ_80C49              ; a←ファンクションキー(読み捨て)
        jp      READ_80C49              ; a←ASCII
        ; 飛び先でリターン
KBHIT_END:

        ; ここにあきなし

; IPL用KEY入力 (アドレス固定)
; キー入力を待つ
; 戻り値
;   a : KEYコード
; レジスタ破壊 af
; 15バイト
ORG_038A:
        ; org     038ah
IPLKEY:
        push    bc

IPLKEY_1:
        call    KBHIT
        or      a
        jr      nz, IPLKEY_1            ; 連続しないよう，キーアップを確認する

IPLKEY_2:
        call    KBHIT
        or      a
        jr      z, IPLKEY_2

        pop     bc
        ret
IPLKEY_END


; 80C49(サブCPU)の書込み可能待ち (アドレス変えてもよい)
; レジスタ破壊 af bc
; 10バイト
WAIT_80C49_WR:
        ld      bc, IO8255B
WAIT_80C49_WR_1:
        in      a, (c)
        and     40h
        jr      nz, WAIT_80C49_WR_1
        ret
WAIT_80C49_WR_END:


; 80C49(サブCPU)の読出し
; 読出し可能を待ってから1バイト読む
; レジスタ破壊 af bc
; 15バイト
READ_80C49:
        ld      bc, IO8255B
READ_80C49_1:
        in      a, (c)
        and     20h
        jr      nz, READ_80C49_1

        ld      bc, IO80C49
        in      a, (c)
        ret
READ_80C49_END:

; ----------------------------------------------------------
; テキスト関係ルーチン (2)
; ----------------------------------------------------------

; IPL用メッセージ表示(座標指定)
; パラメータ
;   de : 表示位置とメッセージのアドレス(00終端)
;   (0ff86h) TXTATR アトリビュート
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 af de
; 12バイト
IPLPRN_XY:
        push    bc                      ; 最後にpop bcされてしまうので
        ex      de, hl
        ld      c, (hl)
        inc     hl
        ld      b, (hl)
        inc     hl
        ex      de, hl

        call    LD_TEXT_ADDR_1
        jr      IPLPRN_1                ; 飛び先でret
IPLPRN_XY_END:


; IPL用1文字表示(レジスタ破壊)
; パラメータ
;   a : 文字コード
;   bc : VRAMアドレス
;   (0ff86h) TXTATR アトリビュート
; 戻り値
;   bc : VRAMアドレス
; レジスタ破壊 af bc
; 13バイト
IPL_PUTCHAR:
        out     (c), a
        res     BIT_ATTR_TEXT, b        ; アトリビュートアドレスに変換
                                        ; 例えば 30aah → 20aah
        ld      a, (TXTATR)
        out     (c), a
        set     BIT_ATTR_TEXT, b        ; テキストアドレスに変換
        inc     bc
        ret
IPL_PUTCHAR_END:

        ; ここにあきなし

; IPL用メッセージ表示 (アドレス固定)
; パラメータ
;   de : メッセージのアドレス(00終端)
;   (0ff80h) TXTCUR カーソルxy
;   (0ff86h) TXTATR アトリビュート
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 de
; 14バイト
ORG_03CB:
        ; org     03cbh
IPLPRN:
        push    bc
        call    LD_TEXT_ADDR
IPLPRN_1
        ld      a, (de)
        or      a
        jr      z, IPLPTC_EXIT          ; メモリ足りないので後処理を共用している
        call    IPL_PUTCHAR
        inc     de
        jr      IPLPRN_1
IPLPRN_END:                             ; アドレス 03d9h

        ; ここにあきなし

; IPL用1文字表示 (アドレス固定)
; パラメータ
;   a : 文字コード
;   (0ff80h) TXTCUR カーソルxy
;   (0ff86h) TXTATR アトリビュート
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 なし
; 15バイト
ORG_03D9:
        ; org     03d9h
IPLPTC:
        push    af
        call    IPLPTC_1
        pop     af
        ret
IPLPTC_1:
        push    bc
        push    af
        call    LD_TEXT_ADDR
        pop     af
        call    IPL_PUTCHAR

; IPL用1文字表示の後処理
; IPLPTCとIPLPRNで共用している
; 5バイト
IPLPTC_EXIT:
        call    ST_CUR_ADDR
        pop     bc
        ret
IPLPTC_END:                             ; アドレス 03edh (残り19バイト)


; 表示アドレス計算
; パラメータ
;   (0ff80h) TXTCUR カーソルxy
; 戻り値
;   bc : VRAMアドレス
; レジスタ破壊 af bc
; 9バイト
LD_TEXT_ADDR:
        ld      bc, (TXTCUR)
LD_TEXT_ADDR_1:
        ld      a, HIGH(IOTEXT)
        add     a, b
        ld      b, a
        ret
LD_TEXT_ADDR_END:


; カーソルアドレス計算
; パラメータ
;   bc : VRAMアドレス
; 戻り値
;   (0ff80h) TXTCUR カーソルxy
; レジスタ破壊 af bc
; 9バイト
ST_CUR_ADDR:
        ld      a, -(HIGH(IOTEXT))
        add     a, b
        ld      b, a
        ld      (TXTCUR), bc
        ret
ST_CUR_ADDR_END:

        ; ここに1バイトあき
        nop

; ----------------------------------------------------------
; ここまでで1KB
; ----------------------------------------------------------

        org     0400h

; ----------------------------------------------------------
; CMT関連ルーチン
; ----------------------------------------------------------

; CMTの準備確認
; 戻り値
;   キャリ : 準備未完で1
; レジスタ破壊 af
; 5バイト
IS_CMT_READY:
        ; 状態取得
        call    MT_STAT
        dec     a                       ; テープ未セットで0
        ret
IS_CMT_READY_END:


; CMTからのファイルの読込みと実行(後半)
; 34バイト
IPL_CMT:
        ; ファイル本体の読込み
        ld      bc, IO8255B
        ld      de, (FILEBUF+12h)       ; プログラムサイズ(byte)
        ld      hl, (FILEBUF+14h)       ; ロードアドレス
        ld      a, 2                    ; 2=再生コマンド
        call    MT_CTRL                 ; 再生開始
        call    CMT_LOADFILE
        push    af

        ld      a, 1                    ; 1=停止コマンド
        call    MT_CTRL                 ; 停止

        pop     af
        jp      c, ERR_LOAD             ; 読込み異常

IPL_CMT_1:
        ; IPL終了
        ld      bc, IOIPLOF
        jp      REDIREC                 ; IPL終了
IPL_CMT_END


; 
; 22バイト
CMT_LOAD1ST:
        ; IPL中なので割り込み禁止のはず
;        di                              ; ここから割り込み禁止区間
        ld      a, 2                    ; 2=再生コマンド
        call    MT_CTRL                 ; 再生開始

        ld      hl, FILEBUF
        ld      bc, IO8255B

        call    CMT_LOADIFB
        push    af

        ld      a, 1                    ; 1=停止コマンド
        call    MT_CTRL                 ; 停止
;        ei                              ; ここまで割り込み禁止区間
        ; IPL中なのでずっと割り込み禁止にしてある

        pop     af

        ret
CMT_LOAD1ST_END:


; CMTインフォメーションブロックの読込み
; パラメータ
;   bc : IO8255B (1a01h)
;   hl : 読込みバッファのアドレス
; 戻り値
;   キャリ : BREAKや異常終了なら1
; レジスタ破壊 af de hl
;
; 割り込み禁止状態で呼び出すこと
; 
; 32バイト
CMT_LOADIFB:
        ; リーダー部の1(不定個数と想定)を読み飛ばす
        call    MT_SKIP1111
        jr      c, CMT_LOADIFB_EXIT     ; 異常終了

        ; リーダー部の0を40個，読み飛ばす
        ld      d, 40 - 1               ; 1を読み飛ばす時点で既に1個 読んでいる
        call    MT_SKIP0
        jr      c, CMT_LOADIFB_EXIT     ; 異常終了

        ; リーダー部の1を41個，読み飛ばす
        ld      d, 41
        call    MT_SKIP1
        jr      c, CMT_LOADIFB_EXIT     ; 異常終了

        ; インフォメーションブロック32byte + チェックサム2byte
        ld      e, 34
CMT_LOADIFB_1:
        call    MT_RDBYTE
        ld      (hl), d
        inc     hl
        jr      c, CMT_LOADIFB_EXIT     ; 異常終了
        dec     e
        jr      nz, CMT_LOADIFB_1

CMT_LOADIFB_EXIT:
        ret
CMT_LOADIFB_END:


; CMTデータ本体の読込み
; パラメータ
;   bc : IO8255B (1a01h)
;   de : データ長
;   hl : 読込みバッファのアドレス
; 戻り値
;   キャリ : BREAKや異常終了なら1
; レジスタ破壊 af de hl
;
; 割り込み禁止状態で呼び出すこと
; 
; 36バイト
CMT_LOADFILE:
        push    de

        ; リーダー部の1(不定個数と想定)を読み飛ばす
        call    MT_SKIP1111
        jr      c, CMT_LOADFILE_EXIT    ; 異常終了

        ; リーダー部の0を20個，読み飛ばす
        ld      d, 20 - 1               ; 1を読み飛ばす時点で既に1個 読んでいる
        call    MT_SKIP0
        jr      c, CMT_LOADFILE_EXIT    ; 異常終了

        ; リーダー部の1を21個，読み飛ばす
        ld      d, 21
        call    MT_SKIP1
        jr      c, CMT_LOADFILE_EXIT    ; 異常終了

        ; データ本体
CMT_LOADFILE_1:
        call    MT_RDBYTE
        ld      (hl), d
        inc     hl
        jr      c, CMT_LOADFILE_EXIT    ; 異常終了
        pop     de
        dec     de
        push    de
        ld      a, d
        or      e
        jr      nz, CMT_LOADFILE_1

CMT_LOADFILE_EXIT:
        pop     de

        ret
CMT_LOADFILE_END:


; カセットコントロール
; パラメータ
;   a : コマンド
;       0 = EJECT
;       1 = STOP
;       2 = READ
;       3 = FF
;       4 = REW
;       5 = APSS+1
;       6 = APSS-1
;       a = WRITE
; レジスタ破壊 f
; リターン時に割り込み禁止になっている
; 
; 28バイト
MT_CTRL:
        push    bc
        push    af

        ei                              ; サブCPUとの通信時に必要？
        call    WAIT_80C49_WR
        ld      bc, IO80C49
        ld      a, 0e9h                 ; e9=カセットデッキコントロール
        out     (c), a
        call    WAIT_80C49_WR
        di

        call    WAIT_80C49_WR
        ld      bc, IO80C49
        pop     af
        out     (c), a

        pop     bc
        ret
MT_CTRL_END:


; カセットデッキ状態取得
; 戻り値
;   a : 下位4bit
;       0 = EJECT
;       1 = STOP
;       2 = READ
;       3 = FF
;       4 = REW
;       a = WRITE
;   a : 上位4bit
;       10 = テープ回転中(1)/停止中(0)
;       20 = テープセット済み(1)/未セット(0)
;       40 = 録音防止(1)/書込み可(0)
; レジスタ破壊 af
; リターン時に割り込み禁止になっている
; 
; 51バイト
MT_STAT:
        push    bc
        push    hl

        ei                              ; サブCPUとの通信時に必要？
        call    WAIT_80C49_WR
        ld      bc, IO80C49
        ld      a, 0ebh                 ; eb=カセットセンサー読出し
        out     (c), a
        call    WAIT_80C49_WR
        di

        call    READ_80C49              ; a←カセットセンサー
        and     07h
        rlca
        rlca
        rlca
        rlca
        ld      h, a

        ei                              ; サブCPUとの通信時に必要？
        call    WAIT_80C49_WR
        ld      bc, IO80C49
        ld      a, 0eah                 ; ea=カセットデッキ状態読出し
        out     (c), a
        call    WAIT_80C49_WR
        di

        call    READ_80C49              ; a←デッキ状態
        and     0fh
        or      h

        pop     hl
        pop     bc
        ret
MT_STAT_END:


; CMTの信号立ち上がりを待つ
; パラメータ
;   bc : IO8255B (1a01h)
; 戻り値
;   キャリ : BREAKや異常終了なら1
; レジスタ破壊 af
; 18バイト
MT_EDGE:
        ; lowを待つ
        in      a, (c)
        rrca                            ; 4clock
        jr      nc, MT_EDGE_2           ; 12clock
        rrca                            ; 4clock
        jr      c, MT_EDGE              ; 12clock

MT_EDGE_1:
        ; 立ち上がりを待つ
        in      a, (c)
        rrca                            ; 4clock
        jr      nc, MT_EDGE_2           ; 12clock
        rrca                            ; 4clock
        jr      nc, MT_EDGE_1           ; 12clock
        ; キャリが残っている

MT_EDGE_2:
        ccf
        ret
MT_EDGE_END:


; CMTから1bit読み込む
; パラメータ
;   bc : IO8255B (1a01h)
; 戻り値
;   a : 読込みデータが0なら0
;   ゼロ : 読込みデータが0なら0
;   キャリ : BREAKや異常終了なら1
; レジスタ破壊 af
; 15バイト
MT_RDBIT:
        call    MT_EDGE
        jr      c, MT_RDBIT_EXIT        ; 異常終了

        ; 約185usec待つ
        ld      a, 35                   ; 1ループ約4.5usec
                                        ; (ROMなので1ウェイト，RAMなら約4usec)
MT_RDBIT_1:
        dec     a                       ; 4clock
        jr      nz, MT_RDBIT_1          ; 12clock

        ; 判定
        in      a, (c)
        and     02h
MT_RDBIT_EXIT:
        ret
MT_RDBIT_END:


; CMTから1bit読み込み，Dレジスタに入れる
; パラメータ
;   bc : IO8255B (1a01h)
; 戻り値
;   d : 最下位ビットに読込みデータ，上位7ビットは左シフト
;   キャリ : BREAKや異常終了なら1
; レジスタ破壊 af d
; 11バイト
MT_RDBIT_D:
        rlc     d
        call    MT_RDBIT
        jr      c, MT_RDBIT_D_EXIT      ; 異常終了
        jr      z, MT_RDBIT_D_EXIT
        inc     d
MT_RDBIT_D_EXIT:
        ret
MT_RDBIT_D_END:


; CMTの255個以上の1の連続を探して読み飛ばす
; パラメータ
;   bc : IO8255B (1a01h)
; 戻り値
;   キャリ : BREAKや異常終了なら1
; レジスタ破壊 af
;
; 最後に0を1つ読むので注意
;
; 22バイト
MT_SKIP1111:
        push    de

        ; 255個の連続を探す
MT_SKIP1111_1:
        ld      d, 0ffh
MT_SKIP1111_2:
        call    MT_RDBIT
        jr      c, MT_SKIP1111_EXIT     ; 異常終了
        jr      z, MT_SKIP1111_1        ; 0が来たのでカウントリセット
        dec     d
        jr      nz, MT_SKIP1111_2

        ; 残りを読み飛ばす
MT_SKIP1111_3:
        call    MT_RDBIT
        jr      c, MT_SKIP1111_EXIT     ; 異常終了
        jr      nz, MT_SKIP1111_3

MT_SKIP1111_EXIT:
        pop     de
        ret
MT_SKIP1111_END:


; CMTの0を指定個数読み飛ばす
; パラメータ
;   bc : IO8255B (1a01h)
;   d : 個数
; 戻り値
;   d : 残り個数
;   キャリ : BREAKや異常終了なら1
; レジスタ破壊 af d
; 13バイト
MT_SKIP0:
        call    MT_RDBIT
        jr      c, MT_SKIP0_EXIT        ; 異常終了
        scf
        jr      nz, MT_SKIP0_EXIT       ; 異常終了(1が来た)
        dec     d
        jr      nz, MT_SKIP0

        or      a                       ; 正常終了
MT_SKIP0_EXIT:
        ret
MT_SKIP0_END:


; CMTの1を指定個数読み飛ばす
; パラメータ
;   bc : IO8255B (1a01h)
;   d : 個数
; 戻り値
;   d : 残り個数
;   キャリ : BREAKや異常終了なら1
; レジスタ破壊 af d
; 13バイト
MT_SKIP1:
        call    MT_RDBIT
        jr      c, MT_SKIP1_EXIT        ; 異常終了
        scf
        jr      z, MT_SKIP1_EXIT        ; 異常終了(0が来た)
        dec     d
        jr      nz, MT_SKIP1

        or      a                       ; 正常終了
MT_SKIP1_EXIT:
        ret
MT_SKIP1_END:


; CMTから1バイト読み込む
; パラメータ
;   bc : IO8255B (1a01h)
; 戻り値
;   d : 読込んだデータ
;   キャリ : BREAKや異常終了なら1
; レジスタ破壊 af d
;
; スタートビット1bit，データ本体8bit
;
; 34バイト
MT_RDBYTE:
        call    MT_RDBIT                ; スタートビット
        jr      c, MT_RDBYTE_EXIT       ; 異常終了
        scf
        jr      z, MT_RDBYTE_EXIT       ; 異常終了(スタートビットが無い)

        ld      d, 0
        call    MT_RDBIT_D              ; 第7ビット
        call    MT_RDBIT_D              ; 第6ビット
        call    MT_RDBIT_D              ; 第5ビット
        call    MT_RDBIT_D              ; 第4ビット
        call    MT_RDBIT_D              ; 第3ビット
        call    MT_RDBIT_D              ; 第2ビット
        call    MT_RDBIT_D              ; 第1ビット
        call    MT_RDBIT_D              ; 第0ビット
        ; 異常終了時はキャリが立っている
MT_RDBYTE_EXIT:
        ret
MT_RDBYTE_END:

        ; アドレス54eh

; ----------------------------------------------------------
; 追加機能ルーチン (1)
; ----------------------------------------------------------

; RAM 0番地のプログラムを実行する
; turboのIPLの隠し機能……らしい
; 9バイト
EXEC_RAM:
        ; リダイレクタをRAMに書き込む
        ld      de, 0
        call    WRITE_REDIRECTOR
        jp      IPL_LOAD_1              ; IPL終了
EXEC_RAM_EMD:                           ; アドレス 01e9h


; ----------------------------------------------------------
; マシン語モニタ
; ----------------------------------------------------------

EXEC_MON:
        call    CLR_VRAM_ALL

EXEC_MON_1:
        ld      a, '*'
        call    IPLPTC
        call    MON_GETS

        ld      hl, INPBUF
        ld      a, (hl)                 ; コマンドの先頭
        or      20h                     ; 全て小文字に統一
        inc     hl
        call    MON_SKIP_SPC            ; 空白を読み飛ばす

        cp      '#'                     ; 画面クリア
        jr      z, EXEC_MON

        cp      'b'                     ; ブートセクタ読込み
        jr      z, MON_LOAD1ST

        cp      'd'                     ; ダンプ
        jr      z, MON_DUMP

        cp      'g'                     ; 実行(RAMに切り替え)
        jr      z, EXEC_MON_1

        cp      'j'                     ; 実行(ROMのまま)
        jr      z, EXEC_MON_1

        cp      'r'                     ; 終了
        jp      z, IPL_LOOP

        jr      EXEC_MON_1
EXEC_MON_END:


; ダンプコマンド
; パラメータ
;   hl : パラメータ文字列
;   (0ff9eh) MONADR モニタアクセス中アドレス
; 戻り値
;   (0ff9eh) MONADR モニタアクセス中アドレス
; レジスタ破壊 af bc de hl
MON_DUMP:
        ld      a, (hl)
        ex      de, hl

        ld      hl, (MONADR)            ; 指定がないので#MONADRを使う
        or      a
MON_DUMP_1:
        call    nz, MON_HLHEX           ; エラーならキャリ
        jr      c, EXEC_MON_1

        ld      c, 16
MON_DUMP_2:
        call    MON_DUMP1
        dec     c
        jr      nz, MON_DUMP_2

        ld      (MONADR), hl

        jr      EXEC_MON_1
MON_DUMP_END:


; 1行ダンプコマンド
; パラメータ
;   hl : アドレス
; レジスタ破壊 af bc de hl
MON_DUMP1:
        call    MON_PRTHL
        ld      a, ':'
        call    IPLPTC

        ; 16進表示
        push    hl
        ld      b, 8
MON_DUMP1_1:
        ld      a, (hl)
        call    MON_PRTHX
        call    MON_PRINTS
        inc     hl
        djnz    MON_DUMP1_1

        ld      a, '/'
        call    IPLPTC

        ; 文字表示
        pop     hl
        ld      b, 8
MON_DUMP1_2:
        ld      a, (hl)
        call    IPLPTC
        inc     hl
        djnz    MON_DUMP1_2

        call    TXT_LTNL

        ret
MON_DUMP1_END:


; 先頭セクタの読込み
MON_LOAD1ST:
        ld      a, (hl)
        call    SET_IPLDRV
        call    IS_DRV_RDY
        call    nc, LOAD1ST_COM
        jp      EXEC_MON_1
MON_LOAD1ST_END:


; 一行入力
; [out] A : length
;       HL : string
; [destruct] AF BC DE HL
MON_GETS:
        ld      hl, INPBUF

MON_GETS_1:
        call    TXT_CURON
        call    IPLKEY

        cp      ' '
        jr      c, MON_GETS_2           ; コントロールコード

        ; 表示可能文字
        ld      d, a                    ; 退避
        ld      a, l
        cp      LOW(INPBUF + INPSIZ - 1)
        jr      z, MON_GETS_1           ; バッファがいっぱい
        ld      a, d                    ; 復元

        ld      (hl), a
        inc     hl
        call    IPLPTC
        jr      MON_GETS_1

MON_GETS_2:
        cp      08h                     ; DEL
        jr      z, MON_GETS_3

        cp      0dh                     ; CR
        jr      z, MON_GETS_4

        jr      MON_GETS_1

MON_GETS_3:
        ; DELの処理
        ld      a, l
        cp      LOW(INPBUF)
        jr      z, MON_GETS_1           ; バッファの先頭

        dec     hl
        ld      (hl), 0
        push    hl
        call    TXT_BS
        pop     hl
        jr      MON_GETS_1

MON_GETS_4:
        ld      (hl), 0
        call    MON_PRINTS
        call    TXT_LTNL

        ret
MON_GETS_END:


; 空白を読み飛ばす
; パラメータ
;   hl : 文字列アドレス
; レジスタ破壊 hl
MON_SKIP_SPC:
        push    af
MON_SKIP_SPC_1:
        ld      a, (hl)
        cp      ' '
        jr      nz, MON_SKIP_SPC_2
        inc     hl
        jr      MON_SKIP_SPC_1
MON_SKIP_SPC_2:
        pop     af
        ret
MON_SKIP_SPC_END:


; #PRINTS
; 空白を1文字表示する
; レジスタ破壊 af
MON_PRINTS:
        ld      a, ' '
        jp      IPLPTC
        ; omit RET
MON_PRINTS_END:


; #PRTHX
; Aレジスタの内容を2桁の16進数として表示する
; パラメータ
;   a : 数値
; レジスタ破壊 af
MON_PRTHX:
        push    af
        rrca
        rrca
        rrca
        rrca
        call    MON_PRTHX_1
        pop     af
MON_PRTHX_1:
        call    MON_ASC
        jp      IPLPTC
        ; omit RET
MON_PRTHX_AND:


; #PRTHL
; HLレジスタの内容を4桁の16進数として表示する
; パラメータ
;   hl : 数値
; レジスタ破壊 af
MON_PRTHL:
        ld      a, h
        call    MON_PRTHX
        ld      a, l
        jr      MON_PRTHX
        ; omit RET
MON_PRTHL_END:


; #ASC
; Aレジスタの下位4ビットを16進数を表すアスキーコードに変換する
; パラメータ
;   a : 数値(下位4ビットが有効)
; 戻り値
;   a : ASCII code ('0' - '9', 'A' - 'F')
; レジスタ破壊 af
MON_ASC:
        and     0fh

        cp      10
        ccf
        adc     a, 30h
        daa

        ret
MON_ASC_END:


; #HEX
; 16進数を表す1文字のアスキーコードを4ビットの数値に変換する
; パラメータ
;   a : ASCII code ('0' - '9', 'A' - 'F')
; 戻り値
;   a : 数値 (0 - 15)
;   キャリ : エラー時
; レジスタ破壊 af
MON_HEX:
        sub     '0'
        cp      10
        jr      c, MON_HEX_1            ; 0-9
        and     0dfh                    ; 大文字に統一する
        cp      17h
        jr      nc, MON_HEX_1           ; over 'F'(46h)
        cp      11h
        jr      c, MON_HEX_2            ; 3ah - 40h
        sub     7                       ; 'A'(41h) - 'F'(46h)
        scf
MON_HEX_1:
        ccf
MON_HEX_2:
        ret
MON_HEX_END:


; #2HEX
; 16進数を表す2文字を8ビットの数値に変換する
; パラメータ
;   de : 文字列の先頭アドレス
; 戻り値
;   a : 数値 (0 - 255)
;   キャリ : エラー時
; レジスタ破壊 af de(+2される)
MON_2HEX:
        push    hl
        call    MON_2HEX_1
        pop     hl
        ret

MON_2HEX_1:
        ld      a, (de)
        inc     de
        call    MON_HEX                  ; carry if error
        ld      l, a

        ld      a, (de)
        inc     de
        jr      c, MON_2HEX_2

        call    MON_HEX                  ; carry if error
        jr      c, MON_2HEX_2

        sla     l
        sla     l
        sla     l
        sla     l

        add     a, l

MON_2HEX_2:
        ret
MON_2HEX_END:


; #HLHEX
; 16進数を表す2文字を8ビットの数値に変換する
; パラメータ
;   de : 文字列の先頭アドレス
; 戻り値
;   hl : 数値 (0 - 65535)
;   キャリ : エラー時
; レジスタ破壊 af de(+4される) hl
MON_HLHEX:
        call    MON_2HEX_1              ; carry if error
        jr      c, MON_HLHEX_1
        ld      h, a

        call    MON_2HEX_1              ; carry if error
        ld      l, a

        ret
MON_HLHEX_1:
        inc     de
        inc     de
        ret
MON_HLHEX_END:

        ; アドレス 683h
        ; ここに61バイトあき
        nop

; ----------------------------------------------------------
; データ領域
; 計320バイト
; ----------------------------------------------------------
        org     06c0h
DATA_TOP:

; 表示メッセージ
; VRAMオフセット(2バイト), "メッセージ本体", 終端0
MSG_WELCOME:
        dw      40*23+8
        db      "X1 compatible IPL 0.7.2", 0
MSG_ERROR:
        dw      40
        db      "Device error", 0
MSG_WAITING:
        dw      0
        db      "IPL is waiting for the device FD", 0
MSG_LOOKING:
        dw      7                                           ; "IPL is "の部分を省略
        db      "looking for a program from FD", 0
MSG_LOOKCMT:
        dw      34                                          ; "IPL is ～ from "までをFD用から拝借
        db      "CMT", 0
MSG_LOADING:
        dw      0
        db      "IPL is loading ", 0
MSG_MISSING:
        dw      40
        db      "Program not found", 0
MSG_MENU1:
        dw      9
        db      "Make Your device ready", 0
MSG_MENU2:
        dw      40*2+2
        db      "Press selected key to start driving:", 0
MSG_MENU3:
        dw      40*4+11
        db      "0-3:FDD", 0
MSG_MENU4:
        dw      40*5+13
        db      "C:CMT", 0
MSG_MENU5:
        dw      40*6+13
        db      "R:ROM", 0
MSG_MENU6:
        dw      40*7+13
        db      "E:EMM", 0
MSG_MENU7:
        dw      40*8+13
        db      "M:Mon", 0
MSG_MENU8:
        dw      40*9+13
        db      "#:RAM", 0
MSG_END:

; メニューの表示内容
; 17バイト
MSG_ADDR_MENU:
        db      8                       ; メニューの行数
        dw      MSG_MENU1
        dw      MSG_MENU2
        dw      MSG_MENU3
        dw      MSG_MENU4
        dw      MSG_MENU5
        dw      MSG_MENU6
        dw      MSG_MENU7
        dw      MSG_MENU8

; WIDTH40とWIDTH80のCRTC初期化パラメータ
; レジスタR13から逆順にR0までと，1a02h(8255 ポートC)に設定する値
; 28バイト
PARM40: db      0, 0, 0, 0, 7, 0, 28, 25, 2, 31, 52, 45, 40, 55
        db      40h
PARM80: db      0, 0, 0, 0, 7, 0, 28, 25, 2, 31, 56, 89, 80, 111
        db      00h

DATA_END:

        ; ここに9バイトあき
        nop

; ----------------------------------------------------------
; ここまでで2KB
; ----------------------------------------------------------
